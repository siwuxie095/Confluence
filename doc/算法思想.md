[TOC]



# 数据结构与算法分析 Java 语言描述 原书第 3 版



（Data Structures and Algorithm Analysis in Java Third Edition）



作者：马克 · 艾伦 · 维斯（Mark Allen Weiss）

译者：冯舜玺、陈越

版次：2016 年 11 月第 1 版第 3 次印刷



出版社：机械工业出版社（China Machine Press）



PS：就翻译而言，不是很贴切。





## 递归简论




递归的四个基本法则：

（1）基准情形（base case）：必须总要有某些基准的情形，它无需递归就能解出。

（2）不断推进（making progress）：对于那些需要递归求解的情形，每一次递归调用都必须要使状况朝向一种基准情形推进。

（3）设计法则（design rule）：假设所有的递归调用都能运行。

（4）合成效益法则（compound interest rule）：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。



## 联机算法与脱机算法



定义？





## 算法设计技巧



用于求解问题的五种通常类型的算法。对于许多问题，很可能是这些方法中至少有一种方法是可以解决问题的。

（1）贪婪算法（greedy algorithm）

（2）分治算法（divide and conquer）

（3）动态规划（dynamic programming）

（4）随机化算法（randomized algorithm）

（5）回溯算法（backtracking）





### 贪婪算法（greedy algorithm）



贪婪算法分阶段的工作。在每个阶段，可以认为所做决定是好的，而不考虑将来的后果。通常，这意味着选择的是某个局部最优。这种 “眼下能够拿到的就拿” 的策略是这类算法名称的来源。当算法终止时，希望局部最优等于全局最优。如果是这样的话，那么算法就是正确的；否则，算法得到的是一个次最优解（suboptimal solution）。如果不要求绝对最佳答案，那么有时使用简单的贪婪算法生成近似的答案，而不是使用通常产生准确答案所需要的复杂算法。



常见应用：

Dijkstra 算法、Prim 算法、Kruskal 算法、辅币找零钱问题、哈夫曼算法（Huffman's algorithm，哈夫曼编码，用于文件压缩）、近视装箱问题（bin packing problem）





### 分治算法（divide and conquer）



分治算法由两部分组成：

（1）分（divide）：递归解决较小的问题（当然，基本情况除外）。

（2）治（conquer）：然后从子问题的解构建原问题的解。



传统上，在正文中至少含有两个递归调用的例程叫做分治算法，而正文中只含有一个递归调用的例程不是分治算法。一般坚持子问题是不相交的（即基本不重叠）。



分治算法的经典例子：归并排序和快速排序。



斐波那契数列的递归计算，虽然也可以被称为分治算法，但它的效率太低，因为问题实际上根本没有被分割。



所有有效的分治算法都是把问题分成一些子问题，每个子问题都是原问题的一部分，然后进行某些附加的工作以算出最后的答案。



常见应用：

归并排序、快速排序、最近点问题





### 动态规划（dynamic programming）



被数学上递归表示的问题也可以表示成一种递归算法，在许多情形下对朴素的穷举搜索得到显著的性能改进。



任何数据递推公式都可以直接转换成递归算法，但是基本现实是编译器常常不能正确对待递归算法，结果导致低效的程序。当怀疑很可能是这种情况时，必须再给编译器提供一些帮助，将递归算法重新写成非递归算法，让后者把那些子问题的答案系统地记录在一个表内。利用这种方法的一种技巧叫做动态规划。



用一个表代替递归。



动态规划是一种强大的算法设计技巧，它给解提供一个起点。它基本上是首先求解一些更简单问题的分治算法的范例，重要的区别在于这些更简单的问题不是原问题的明显的分割。因为子问题反复被求解，所以重要的是将它们的解记录在一个表中而不是重新计算它们。在某些情况下，解可以被改进（虽然这确实不总是明显的且常常是困难的），而在另一些情况下，动态规划方法则是所知道的最好的处理方法。



在某种意义上，如果你看出一个动态规划问题，那么你就看出所有的动态规划问题。



常见应用：

斐波那契数列、最优二叉查找树、所有点对最短路径





### 随机化算法（randomized algorithm）



在算法期间，随机数至少有一次用于决策。该算法的运行时间不只依赖于特定的输入，而且依赖于所出现的随机数。



一个随机化算法的最坏情形运行时间常常和非随机化算法的最坏情形运行时间相同。重要的区别在于，好的随机化算法没有坏的输入，而只有坏的随机数（相对于特定的输入）。



由于算法需要随机数，因此必须要有一种方法来生成它。实际上，真正的随机性在计算机上是不可能生成的，因为这些数将依赖于算法，从而不可能是随机的。一般说来，产生伪随机数（pseudorandom）就足够了，伪随机数看起来像是随机的数。随机数有许多已知的统计性质；伪随机数满足大部分的这些性质。



常见应用：

随机数发生器、跳跃表、素性测试





### 回溯算法（backtracking）



在许多情况下，回溯算法相当于穷举搜索的巧妙实现，但性能一般不理想。不过，情况并不总是如此，即使是如此，在某些情形下它相对于蛮力穷举搜索的工作量也有显著的节省。当然，性能是相对的：对于排序而言，O(N^2) 的算法是相当差的，但对旅行售货员（或任何 NP 完全）问题，O(N^5) 算法则是里程碑式的结果。



在一步内删除一大组可能性的做法叫做裁剪（pruning）。



常见应用：

收费公路重建问题、博弈（如西洋跳棋、国际象棋）







# 计算机算法设计与分析 第 5 版



作者：王晓东

版次：2018 年 8 月第 5 版第 1 次印刷



出版社：电子工业出版社（Publishing House of Electronics Industry）



采用 C++ 语言作为算法编程工具。



## 递归与分治策略



分治法的设计思想是：将一个难以直接解决的大问题分割成一些规模较小的相同问题，以便各个击破，即分而治之。如果原问题可分割成 k 个子问题，1 < k <= n，且这些子问题都可解，并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题和原问题类型一致而规模不断缩小，最终使子问题缩小到容易求出其解，由此自然引出递归算法。分治与递归像一对孪生兄弟，经常同时应用在算法设计中，并由此产生许多高效算法。



### 递归的概念



直接或间接地调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。



使用递归技术往往使函数的定义和算法的描述简捷且易于理解。有些数据结构，如二叉树等，由于其本身固有的递归特性，特别适合用递归的形式来描述。有些问题，虽然其本身并没有明显的递归结构，但用递归技术来求解，可使设计出的算法简捷易懂且易于分析。



常见应用：

斐波那契数列、汉诺塔问题



### 分治法的基本思想



分治法的基本思想是将一个规模为 n 的问题分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题相同。递归的解这些子问题，然后将各子问题的解合并得到原问题的解。它的一般的算法设计模式如下：

```java
divide-and-conquer(P) {
    if (|P| <= n0) 
        adhoc(P);
    divide P into smaller subinstances P1, P2, ..., Pk;
    for (i = 1; i <= k; i++) 
        yi = divide-and-conquer(Pi);
    return merge(y1, y2, ..., yk);
}
```



其中：
    |P| 表示问题 P 的规模，n0 为一阈值，表示当问题 P 的规模不超过 n0 时，问题容易解出，不必再继续分解。adhoc(P) 是该分治法的基本子算法，用于直接解小规模的问题 P。当 P 的规模不超过 n0 时，直接用算法 adhoc(P) 求解。算法 merge(y1, y2, ..., yk) 是该分治法中的合并子算法，用于将 P 的子问题 P1, P2, ..., Pk 的解 y1, y2, ..., yk 合并为 P 的解。



根据分治法的分割原则，应该把原问题分为多少个子问题才较适宜？每个子问题是否规模相同或怎样才为适当？这些问题很难予以肯定回答。但人们从大量实践中发现，在用分治法设计算法时，最好使子问题的规模大致相同，即将一个问题分成大小相等的 k 个子问题的处理方法是行之有效的。许多问题可以取 k=2。这种使子问题规模大致相等的做法出自一种平衡（balancing）子问题的思想，几乎总是比子问题规模不等的做法要好。



从分治法的一般设计模式可以看出，用它设计出的程序一般是递归算法，因此分治法的计算效率通常可以用递归方程来分析。



### 常见应用：

二分搜索（Binary Search）、大整数的乘法、Strassen 矩阵乘法、棋盘覆盖、合并排序（归并排序）、快速排序、线性时间选择、最接近点对问题、循环赛日程表





## 动态规划



动态规划算法与分治法类似，其基本思想是将待求解问题分解成若干子问题，先求解子问题，再结合这些子问题的解得到原问题的解。与分治法不同的是，适合用动态规划法求解的问题经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，以致最后解决原问题需要耗费指数级时间。然而，不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。如果能够保存已解决的子问题的答案，在需要时再找出已求解的答案，这样可以避免大量的重复计算，从而得到多项式时间算法。为了达到此目的，可以用一个表来记录所有已解决的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思想。具体的动态规划算法多种多样，但它们具有相同的填表格式。



动态规划算法适用于解最优化问题，通常可以按以下 4 个步骤设计：

（1）分析最优解的结构：找出最优解的性质，并刻画其结构特征；

（2）建立递归关系：递归地定义最优值；

（3）计算最优值：以自底向上的方式计算最优值；

（4）构造最优解：根据计算最优值时得到的信息，构造最优解。



步骤（1）~（3）是动态规划算法的基本步骤。在只需要求出最优值的情形下，步骤（4）可以省略。若需要求出问题的最优解，则必须执行步骤（4）。此时，步骤（3）中计算最优值时，通常需记录更多的信息，以便在步骤（4）中，根据所记录的信息，快速构造出一个最优解。





### 动态规划算法的基本要素





动态规划算法的有效性依赖于问题本身所具有的两个重要性质：最优子结构性质和子问题重叠性质。



从一般意义上讲，问题所具有的这两个重要性质是该问题可用动态规划算法求解的基本要素。另外，动态规划还有一个变形：备忘录方法。



#### 1、最优子结构

设计动态规划算法的第一步通常是要刻画最优解的结构。当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。问题的最优子结构性质提供了该问题可用动态规划算法求解的重要线索。



在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归（应该是迭代）地从子问题的最优解逐步构造出整个问题的最优解。算法考察的子问题空间中规模较小。





#### 2、重叠子问题

可用动态规划算法求解的问题应具备的另一基本要素是子问题的重叠性质。在用递归算法自顶向下解此问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算。动态规划算法正是利用了这种子问题的重叠性质，对每个子问题只解一次，然后将其解保存在一个表格中，当再次需要解此问题时，只是简单地用常数时间查看一下结果。通常，不同的子问题个数随问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。





#### 3、备忘录方法

备忘录方法是动态规划的变形。与动态规划算法一样，备忘录方法用表格保存已解决的子问题的答案，在下次需要解此问题时，只需要简单地查看该子问题的解答，而不必重新计算。与动态规划算法不同的是，备忘录算法的递归方式是自顶向下的，而动态规划算法则是自底向上递归（应该是迭代）的。因此，备忘录方法的控制结构与直接递归的控制结构相同，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题重复求解。



备忘录方法为每个子问题建立一个记录项，初始化时，该记录项存入一个特殊的值，表示该子问题尚未求解。在求解过程中，对每个待求的子问题，首先查看其相应的记录项。若记录项中存储的是初始化时存入的特殊值，则表示该子问题是第一次遇到，此时计算出该子问题的解，并保存在其相应的记录项中，以备以后查看。若记录项中存储的已不是初始化时存入的特殊值，则表示该子问题已被计算过，其相应的记录项中存储的是该子问题的解答。此时，只要从记录项中取出该子问题的解答即可，而不必重新计算。



一般来讲，当一个问题的所有子问题都至少要解一次时，用动态规划算法比用备忘录方法好。此时，动态规划算法没有任何多余的计算。同时，对于许多问题，常可利用其规则的表格存取方式，减少动态规划算法的计算时间和空间需求。当子问题空间中的部分子问题可不必求解时，用备忘录方法则较有利，因为从其控制结构可以看出，该方法只解那些确实需要求解的子问题。





### 常见应用：

矩阵连乘问题、最长公共子序列、最大子段和、凸多边形最优三角剖分、多边形游戏、图像压缩、电路布线、流水作业调度、0-1背包问题、最优二叉搜索树、







## 贪心算法



当一个问题具有最优子结构性质时，可用动态规划法求解。有时会有更简单有效的算法。比如，找硬币的例子就适合用贪心算法。顾名思义，贪心算法总是做出在当前看来是最好的选择。也就是说，贪心算法并不从整体最优上加以考虑，所做的选择只是在某种意义上的局部最优选择。当然，我们希望贪心算法得到的最终结果也是整体最优的。



找硬币问题本身具有最优子结构性质，可以用动态规划算法来解，但贪心算法更简单，更直接，且解题效率更高。这利用了问题本身的一些特性。例如，找硬币算法利用了硬币面值的特殊性。虽然贪心算法不是对所有问题都能得到整体最优解，但对范围相当广的许多问题能产生整体最优解，如最小生成树问题、图的单源最短路径问题等。在一些情况下，即使贪心算法不能得到整体最优解，但其最终结果却是最优解的很好的近似解。



### 贪心算法的基本要素

贪心算法通过一系列选择来得到问题的解，所做的每个选择都是当前状态下局部最好的选择，即贪心选择。这种启发式的策略并不总能奏效，但在许多情况下确能达到预期目的。



对于一个具体的问题，怎么知道是否可用贪心算法来解此问题，以及能否得到问题的一个最优解呢？这个问题很难给予肯定的回答。但是，从许多可以用贪心算法求解的问题中可以看到，它们一般具有两个重要的性质：贪心选择性质和最优子结构性质。



#### 1、贪心选择性质

贪心选择性质是指，所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。



在动态规划算法中，每步所做的选择往往依赖于相关子问题的解。因而只有解出相关子问题后，才能做出选择。



而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择。再去解做出这个选择后产生的相应的子问题。



贪心算法所做的贪心选择考研依赖以往所做过的选择，但决不依赖将来所做的选择，也不依赖子问题的解。正是由于这种差别，动态规划算法通常是以自底向上的方式解各子问题，贪心算法则通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为规模更小的子问题。



对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每步所做的贪心选择最终导致问题的整体最优解。首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。做了贪心选择后，原问题简化为规模更小的类似子问题。然后用数学归纳法证明，通过每一步做贪心选择，最终可得到问题的整体最优解。其中，证明贪心选择后的问题简化为规模更小的类似子问题的关键在于，利用该问题的最优子结构性质。



#### 2、最优子结构性质

当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。







### 常见应用：

活动安排问题、最优装载问题、哈夫曼编码、单源最短路径、最小生成树、多机调度问题





## 回溯法

回溯法有 “通用的解题法” 之称，可以系统地搜索一个问题的所有解或任一解，它是一个既带有系统性又带有跳跃性的搜索算法。在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树，算法搜索至解空间树的任一结点时，先判断该结点是否包含问题的解，如果肯定不包含，则跳过对以该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。回溯法求问题的所有解时，要回溯到根，且根节点的所有子树都已被搜索到才结束。回溯法求问题的一个解时，只要搜索到问题的一个解就可结束。这种以深度优先的方式系统搜索问题解的算法称为回溯法，适合解组合数较大的问题。





### 回溯法的算法框架



#### 1、问题的解空间

用回溯法求解问题时，应明确定义问题的解空间。问题的解空间至少应包含问题的一个（最优）解。



定义了问题的解空间后，还应将解空间很好地组织起来，使得能用回溯法方便地搜索整个解空间。通常将解空间组织成树或图的形式。



#### 2、回溯法的基本思想

确定了解空间的组织结构后，回溯法从开始结点（根节点）出发，以深度优先方式搜索整个解空间。这个开始结点成为活结点，同时成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。回溯法以这种工作方式递归地在解空间中搜索，直至找到所要求的解或解空间中已无活结点时为止。



回溯法搜索解空间树时，通常采用两种策略来避免无效搜索，提高回溯法的搜索效率。其一是用约束函数在扩展结点处剪去不满足约束的子树，其二是用限界函数剪去得不到最优解的子树。这两类函数统称为剪枝函数。



综上所述，用回溯法解题通常包含以下 3 个步骤：

（1）针对所给问题，定义问题的解空间；

（2）确定易于搜索的解空间结构；

（3）以深度优先的方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。





#### 3、递归回溯

回溯法对解空间作深度优先搜索，因此在一般情况下可用递归函数来实现回溯法如下：

```java
void backtrack(int t) {
    if (t > n) {
        output(x);
    } else {
        for (int i = f(n, t); i <= g(n, t); i++) {
            x[t] = h(i);
        }
        if (constraint(t) && bound(t)) {
            backtrack(t + 1);
        }
    }
}
```



其中，形式参数 t 表示递归深度，即当前扩展结点在解空间树中的深度。n 用来控制递归深度，当 t > n 时，算法已搜索到叶结点。此时，由 output(x) 记录或输出得到可行解 x。算法 backtrack 的 for 循环中的 f(n, t) 和 g(n, t) 分别表示在当前扩展节点处未搜索过的子树的起始编号和终止编号。h(i) 表示在当前扩展结点处 x[t] 的第 i 个可选值。constraint(t) 和 bound(t) 表示在当前扩展结点处的约束函数和限界函数。constraint(t) 返回的值为 true 时，在当前扩展结点处 x[1:t] 的取值满足问题的约束条件，否则不满足问题的约束条件，可减去相应的子树。bound(t) 返回的值为 true 时，在当前扩展结点处 x[1:t] 的取值未使目标函数越界，还需由 backtrack(t + 1) 对其相应的子树做进一步的搜索。否则，当前扩展结点处 x[1:t] 的取值使目标函数越界，可减去相应的子树。执行了算法的 for 循环后，已搜索当前扩展结点的所有未搜索过的子树。backtrack(t) 执行完毕，返回 t - 1 层继续执行，对还没有测试过的 x[t-1] 的继续搜索。当 t = 1 时，若已测试完 x[1] 的所有可选值，外层调用就全部结束。显然，这一搜索过程按深度优先方式进行。调用一次 backtrack(1) 即可完成整个回溯搜索过程。



#### 4、迭代回溯

采用树的非递归深度优先遍历算法，也可将回溯法表示为一个非递归的迭代过程如下：

```java
void interativeBacktrack(void) {
    int t = 1;
    while (t > 0) {
        if (f(n, t) <= g(n, t)) {
            for (int i = f(n, t); i <= g(n, t); i++) {
                x[t] = h(i);
                if (constraint(t) && bound(t)) {
                    if(solution(t)) {
                        output(x);
                    } else {
                        t++;
                    }
                }   
            }
        } else {
            t--;
        }
    }
}
```



上述迭代回溯算法中，用 solution(t) 判断在当前扩展结点处是否已得到问题的可行解。它返回的值为 true 时，在当前扩展结点处 x[1:t] 是问题的可行解。此时，由 output(x) 记录或输出得到的可行解。它返回的值 false 时，在当前扩展结点处 x[1:t] 只是问题的部分解，还需向纵深方向继续搜索。算法中 f(n, t) 和 g(n, t) 分别表示在当前扩展结点处未搜索过的子树的起始编号和终止编号。h(i) 表示在当前扩展节点处 x[t] 的第 i 个可选值。constraint(t) 和 bound(t) 是当前扩展结点处的约束函数和限界函数。constraint(t) 返回的值为 true 时，在当前扩展结点处 x[1:t] 的取值满足问题的约束条件，否则不满足问题的约束条件，可剪去相应的子树。bound(t) 返回的值为 true 时，在当前扩展结点处 x[1:t] 的取值未使目标函数越界，还需对其相应的子树做进一步搜索。否则，当前扩展结点处 x[1:t] 的取值已使目标函数越界，可剪去相应的子树。算法的 while 循环结束后，完成整个回溯搜索过程。



用回溯法阶解题的一个显著特征是，在搜索过程中动态产生问题的解空间。在任何时刻，算法只保存从根结点到当前扩展结点的路径。如果解空间树中从根结点到叶结点的最长路径的长度为 h(n)，则回溯法所需的计算空间通常为 O(h(n))。显式地存储整个解空间则需要 O(2^h(n)) 或 O(h(n)!) 内存空间。



#### 5、子集树与排列树

用回溯法解题时常遇到的两类典型的解空间树是：子集树和排列树。



当所给的问题是从 n 个元素的集合 S 中找出某种性质的子集时，相应的解空间树称为子集树。例如，n 个物品的 0-1 背包问题所相应的解空间树就是一棵子集树。这类子集树通常有 2^n 个叶结点，其结点总个数为 2^(n+1) - 1。遍历子集树的任何算法均需 O(2^n) 的计算时间。



当所给的问题是确定 n 个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有 n! 个叶结点。因此遍历排列树需要 O(n!) 的计算时间。例如，旅行售货员问题的解空间树就是一棵排列树。



用回溯法搜索子集树的一般算法可描述如下：

```java
void backtrack(int t) {
    if (t > n) {
        output(x);
    } else {
        for (int i = 0; i <= 1; i++) {
            x[t] = i;
            if (constraint(t) && bound(t)) 
            	backtrack(t + 1);
        }
    }
}
```



用回溯法搜索排列树的算法框架可描述如下：

```java
void backtrack(int t) {
    if (t > n) {
        output(x);
    } else {
        for (int i = 0; i <= 1; i++) {
            swap(x[t], x[i]);
            if (constraint(t) && bound(t)) 
            	backtrack(t + 1);
            swap(x[t], x[i]);
        }
    }
}
```

在调用 backtrack(1) 执行回溯搜索前，先将变量数组 x 初始化为单位排列 (1, 2, ..., n)。

 

### 常见应用：

装载问题、批处理作业调度、符号三角形问题、n后问题、0-1背包问题、最大团问题、图的m着色问题、旅行售货员问题、圆排列问题、电路板排列问题、连续邮资问题





## 分支限界法

分支限界法类似回溯法，也是在问题的解空间上搜索问题解的算法。一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出解空间中满足约束条件的所有解，而分支限界法的求解目标是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。



由于求解目前不同，导致分支限界法与回溯法对解空间的搜索方式也不同。回溯法以深度优先的方式搜索解空间，分支限界法则以广度优先或以最小耗费优先的方式搜索解空间。分支限界法的搜索策略是，在扩展结点处，先生成其所有儿子结点（分支），再从当前的活结点表中选择下一个扩展结点。为了有效地选择下一扩展结点，加速搜索的进程，在每个活结点处，计算一个函数值（限界），并根据函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间上有最优解的分支推进，以便尽快地找出一个最优解。这种方法称为分支限界法。人们已经用分支限界法解决了大量离散优化问题。



### 分支限界法的基本思想



分支限界法常以广度优先或最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法的主要区别在于它们对当前扩展结点所采用的扩展方式不同。



在分支限界法中，每个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点列表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。



从活结点表中选择下一扩展结点的不同方式导致不同的分支限界法。最常见的有以下两种方式。



#### 1、队列式（FIFO）分支限界法



队列式分支限界法将活结点表组织成一个队列，并按队列的先进先出原则选取下一结点为当前扩展结点。



#### 2、优先队列式分支限界法



优先队列式的分支限界法将活结点表组织成一个优先队列，并按优先队列中规定的结点优先级选取优先级最高的下一个结点成为当前扩展结点。



优先队列中规定的结点优先级常用一个与该结点相关的数值 p 来表示。结点优先级的高低与 p 值的大小相关。最大优先队列规定 p 值较大的结点优先级较高。在算法实现时，通常用最大堆来实现最大优先队列，用最大堆的 deleteMax 运算抽取堆中下一个结点成为当前扩展结点，体现最大效益优先的原则。类似地，最小优先队列规定 p 值较小的结点优先级较高。在算法实现时，通常用最小堆来实现最小优先队列，用最小堆的 deleteMin 运算抽取堆中下一个结点成为当前扩展结点，体现最小费用优先原则。



用优先队列式分支限界法解具体问题时，应根据具体问题的特点确定选用最大优先队列或最小优先队列来表示解空间的活结点表。



在寻求问题的最优解时，与讨论回溯法时类似，可以用剪枝函数加速搜索。该函数给出每一个可行结点相应的子树可能获得的最大价值的上界。如果这个上界不会比当前最优值更大，则说明相应的子树中不含问题的最优解，因而可以剪去。另一方面，可以将上界函数确定的每个结点的上界值作为优先级，以该优先级的非增序抽取当前扩展结点。这种策略有时可以更迅速地找到最优解。



或者可以用一个限界函数在搜索过程中裁剪子树，以减少产生的活结点。此时剪枝函数是当前节点扩展后得到的最小费用的下界。如果在当前扩展结点处，这个下界不比当前最优值更小，则剪去以该结点为根的子树。另一方面，可以把每个结点的下界作为优先级，依非减序从活结点优先队列中抽取下一个扩展结点。









### 常用应用：

单源最短路径问题、装载问题、布线问题、0-1 背包问题、最大团问题、旅行售货员问题、电路板排列问题、批处理作业调度问题





## 随机化算法



随机化算法大致分为 4 类：

（1）数值随机化算法

（2）蒙特卡罗（Monte Carlo）算法

（3）拉斯维加斯（Las Vegas）算法

（4）舍伍德（Sherwood）算法







## 线性规划与网络流

暂时不必看



## 串与序列的算法

KMP、后缀数组、编辑距离









# 算法设计与分析基础 第 3 版



（Introduction to The Design and  Analysis of Algorithm Third Edition）



作者：Anany Levitin

译者：潘彦

版次：2015 年 2 月第 3 版第 1 次印刷



出版社：清华大学出版社



作者基于丰富的教学经验，开发了一套全新的算法分类方法。该分类法站在通用问题求解策略的高度，对现有大多数算法准确分类，从而引领读者沿着一条清晰、一致、连贯的思路来探索算法设计与分析这一迷人领域。







# 算法设计技巧与分析



（Algorithms Design Techniques and Analysis）



作者：阿苏外耶（M. H. Alsuwaiyel）

译者：吴伟昶、方世昌

版次：2004 年 8 月



出版社：电子工业出版社（Publishing House of Electronics Industry）









# 算法导论 原书第 3 版



（Introduction to Algorithms Third Edition）



作者：Thomas H. Cormen、Charles E. Leiserson、Ronald L. Rivest、Clifford Stein

译者：殷建平、徐云、王刚、刘晓光、苏明、邹恒明、王宏志

版次：2013 年 1 月第 1 版第 1 次印刷



出版社：机械工业出版社（China Machine Press）







# 算法设计



（Algorithm Design）



作者：Jon Kleinberg、Eva Tardos

译者：张立昂、屈婉玲

版次：2007 年 3 月第 1 版第 1 次印刷



出版社：清华大学出版社











# 算法设计指南 第 2 版



（The Algorithm Design Manual Second Edition）



作者：Steven S. Skiena

译者：谢勰

版次：2017 年 7 月第 1 版第 1 次印刷



出版社：清华大学出版社







