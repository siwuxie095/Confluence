[TOC]



# 数据结构与算法分析 Java 语言描述 原书第 3 版



PS：就翻译而言，不是很贴切。





## 递归简论




递归的四个基本法则：

（1）基准情形（base case）：必须总要有某些基准的情形，它无需递归就能解出。

（2）不断推进（making progress）：对于那些需要递归求解的情形，每一次递归调用都必须要使状况朝向一种基准情形推进。

（3）设计法则（design rule）：假设所有的递归调用都能运行。

（4）合成效益法则（compound interest rule）：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。





## 算法设计技巧



用于求解问题的五种通常类型的算法。对于许多问题，很可能是这些方法中至少有一种方法是可以解决问题的。

（1）贪婪算法（greedy algorithm）

（2）分治算法（divide and conquer）

（3）动态规划（dynamic programming）

（4）随机化算法（randomized algorithm）

（5）回溯算法（backtracking）





### 贪婪算法（greedy algorithm）



贪婪算法分阶段的工作。在每个阶段，可以认为所做决定是好的，而不考虑将来的后果。通常，这意味着选择的是某个局部最优。这种 “眼下能够拿到的就拿” 的策略是这类算法名称的来源。当算法终止时，希望局部最优等于全局最优。如果是这样的话，那么算法就是正确的；否则，算法得到的是一个次最优解（suboptimal solution）。如果不要求绝对最佳答案，那么有时使用简单的贪婪算法生成近似的答案，而不是使用通常产生准确答案所需要的复杂算法。





### 分治算法（divide and conquer）



分治算法由两部分组成：

（1）分（divide）：递归解决较小的问题（当然，基本情况除外）。

（2）治（conquer）：然后从子问题的解构建原问题的解。



传统上，在正文中至少含有两个递归调用的例程叫做分治算法，而正文中只含有一个递归调用的例程不是分治算法。一般坚持子问题是不相交的（即基本不重叠）。



分治算法的经典例子：归并排序和快速排序。



斐波那契数列的递归计算，虽然也可以被称为分治算法，但它的效率太低，因为问题实际上根本没有被分割。



所有有效的分治算法都是把问题分成一些子问题，每个子问题都是原问题的一部分，然后进行某些附加的工作以算出最后的答案。





### 动态规划（dynamic programming）



被数学上递归表示的问题也可以表示成一种递归算法，在许多情形下对朴素的穷举搜索得到显著的性能改进。



任何数据递推公式都可以直接转换成递归算法，但是基本现实是编译器常常不能正确对待递归算法，结果导致低效的程序。当怀疑很可能是这种情况时，必须再给编译器提供一些帮助，将递归算法重新写成非递归算法，让后者把那些子问题的答案系统地记录在一个表内。利用这种方法的一种技巧叫做动态规划。



用一个表代替递归。



动态规划是一种强大的算法设计技巧，它给解提供一个起点。它基本上是首先求解一些更简单问题的分治算法的范例，重要的区别在于这些更简单的问题不是原问题的明显的分割。因为子问题反复被求解，所以重要的是将它们的解记录在一个表中而不是重新计算它们。在某些情况下，解可以被改进（虽然这确实不总是明显的且常常是困难的），而在另一些情况下，动态规划方法则是所知道的最好的处理方法。



在某种意义上，如果你看出一个动态规划问题，那么你就看出所有的动态规划问题。





### 随机化算法（randomized algorithm）



在算法期间，随机数至少有一次用于决策。该算法的运行时间不只依赖于特定的输入，而且依赖于所出现的随机数。



一个随机化算法的最坏情形运行时间常常和非随机化算法的最坏情形运行时间相同。重要的区别在于，好的随机化算法没有坏的输入，而只有坏的随机数（相对于特定的输入）。



由于算法需要随机数，因此必须要有一种方法来生成它。实际上，真正的随机性在计算机上是不可能生成的，因为这些数将依赖于算法，从而不可能是随机的。一般说来，产生伪随机数（pseudorandom）就足够了，伪随机数看起来像是随机的数。随机数有许多已知的统计性质；伪随机数满足大部分的这些性质。





### 回溯算法（backtracking）



在许多情况下，回溯算法相当于穷举搜索的巧妙实现，但性能一般不理想。不过，情况并不总是如此，即使是如此，在某些情形下它相对于蛮力穷举搜索的工作量也有显著的节省。当然，性能是相对的：对于排序而言，O(N^2) 的算法是相当差的，但对旅行售货员（或任何 NP 完全）问题，O(N^5) 算法则是里程碑式的结果。



在一步内删除一大组可能性的做法叫做裁剪（pruning）。